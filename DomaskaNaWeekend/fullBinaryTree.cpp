#include "fullBinaryTree.h"
#include <iostream>
#include <string>

using namespace std;

struct QueueNode {
    Node* treeNode;      // указатель на узел дерева
    QueueNode* next; // указатель на следующий узел в очереди

    QueueNode(Node* node) : treeNode(node), next(nullptr) {}    // Конструктор
};

struct SimpleQueue {
    QueueNode* front; 
    QueueNode* rear;
    int size;

    SimpleQueue() : front(nullptr), rear(nullptr), size(0) {}

    ~SimpleQueue() {
        while (!isEmpty()) {
            dequeue();
        }
    }

    void enqueue(Node* node) {
        QueueNode* newNode = new QueueNode(node);
        if (rear == nullptr) {
            front = rear = newNode;
        }
        else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }

    Node* dequeue() {
        if (front == nullptr) return nullptr;

        QueueNode* temp = front;
        Node* node = temp->treeNode;
        front = front->next;

        if (front == nullptr) {
            rear = nullptr;
        }

        delete temp;
        size--;
        return node;
    }

    bool isEmpty() {
        return front == nullptr;
    }

    int getSize() {
        return size;
    }
};

// Вставка элемента в дерево (уровень за уровнем)
void insertBinary(fullBinaryTree* tree, const string& value) {
    Node* newNode = new Node(value);

    if (!tree->root) {
        tree->root = newNode;
        return;
    }

    // Ищем место для вставки, сравнивая значения как ЧИСЛА
    Node* current = tree->root;
    Node* parent = nullptr;

    while (current != nullptr) {
        parent = current;

        // Преобразуем строки в числа для сравнения
        int valueNum = stoi(value);
        int currentNum = stoi(current->data);

        if (valueNum < currentNum) {
            current = current->left;
        }
        else if (valueNum > currentNum) {
            current = current->right;
        }
        else {
            // Если значение уже существует, не добавляем дубликат
            delete newNode;
            return;
        }
    }

    // Вставляем новый узел
    int valueNum = stoi(value);
    int parentNum = stoi(parent->data);

    if (valueNum < parentNum) {
        parent->left = newNode;
    }
    else {
        parent->right = newNode;
    }
}
string getBFSAsString(fullBinaryTree* tree) {
    string result;
    if (!tree->root) return result;

    SimpleQueue q;
    q.enqueue(tree->root);

    while (!q.isEmpty()) {
        Node* temp = q.dequeue();
        result += temp->data + " ";

        if (temp->left) q.enqueue(temp->left);
        if (temp->right) q.enqueue(temp->right);
    }

    if (!result.empty()) {
        result.pop_back(); // Удаляем последний пробел
    }
    return result;
}


// Рекурсивная очистка дерева
void clearTree(Node* node) {
    if (node == nullptr) return;
    clearTree(node->left);
    clearTree(node->right);
    delete node;
}

// Очистка всего дерева
void clearFullBinaryTree(fullBinaryTree* tree) {
    clearTree(tree->root);
    tree->root = nullptr;
}

// Симметричный обход (левый-корень-правый)
void inorder(Node* node) {
    if (!node) return;
    inorder(node->left);
    cout << node->data << " ";
    inorder(node->right);
}

// Прямой обход (корень-левый-правый)
void preorder(Node* node) {
    if (!node) return;
    cout << node->data << " ";
    preorder(node->left);
    preorder(node->right);
}

// Обратный обход (левый-правый-корень)
void postorder(Node* node) {
    if (!node) return;
    postorder(node->left);
    postorder(node->right);
    cout << node->data << " ";
}

// Поиск в ширину (BFS)
Node* BFS(fullBinaryTree* tree, const string& value) {
    if (!tree->root) return nullptr;

    SimpleQueue q;
    q.enqueue(tree->root);

    while (!q.isEmpty()) {
        Node* temp = q.dequeue();
        if (temp->data == value) return temp;

        if (temp->left) q.enqueue(temp->left);
        if (temp->right) q.enqueue(temp->right);
    }

    return nullptr;
}

// Вывод дерева в ширину
void printBFS(fullBinaryTree* tree) {
    if (!tree->root) {
        cout << "Дерево пустое" << endl;
        return;
    }

    SimpleQueue q;
    q.enqueue(tree->root);

    cout << "Обход в ширину: ";
    while (!q.isEmpty()) {
        Node* temp = q.dequeue();
        cout << temp->data << " ";

        if (temp->left) q.enqueue(temp->left);
        if (temp->right) q.enqueue(temp->right);
    }
    cout << endl;
}

// Проверка на полное бинарное дерево (Complete Binary Tree)
bool isCompleteBinaryTree(Node* root) {
    if (!root) return true;

    SimpleQueue q;
    q.enqueue(root);
    bool foundNull = false;

    while (!q.isEmpty()) {
        Node* temp = q.dequeue();

        // Проверяем левого потомка
        if (temp->left) {
            if (foundNull) return false;  // Нашли узел после null
            q.enqueue(temp->left);
        }
        else {
            foundNull = true;
        }

        // Проверяем правого потомка
        if (temp->right) {
            if (foundNull) return false;  // Нашли узел после null
            q.enqueue(temp->right);
        }
        else {
            foundNull = true;
        }
    }
    return true;
}
// Проверка на строго полное бинарное дерево (Full/Strict Binary Tree)
bool isFullBinaryTree(Node* root) {
    if (!root) return true;

    // Если у узла нет детей - это лист
    if (!root->left && !root->right) return true;

    // Если у узла оба ребенка - проверяем рекурсивно
    if (root->left && root->right) {
        return isFullBinaryTree(root->left) && isFullBinaryTree(root->right);
    }

    // Если только один ребенок - не строго полное
    return false;
}
// Рекурсивная функция для получения inorder в виде строки
void getInorderHelper(Node* node, string& result) {
    if (!node) return;
    getInorderHelper(node->left, result);
    result += node->data + " ";
    getInorderHelper(node->right, result);
}

string getInorderAsString(Node* node) {
    string result;
    getInorderHelper(node, result);
    if (!result.empty()) {
        result.pop_back(); // Удаляем последний пробел
    }
    return result;
}
// Функция для проверки и вывода типа дерева
void checkTreeType(fullBinaryTree* tree) {
    if (!tree->root) {
        cout << "Дерево пустое" << endl;
        return;
    }

    bool complete = isCompleteBinaryTree(tree->root);
    bool full = isFullBinaryTree(tree->root);

    cout << "=== АНАЛИЗ ДЕРЕВА ===" << endl;

    // Подсчет узлов
    int count = 0;
    SimpleQueue q;
    if (tree->root) q.enqueue(tree->root);
    while (!q.isEmpty()) {
        Node* temp = q.dequeue();
        count++;
        if (temp->left) q.enqueue(temp->left);
        if (temp->right) q.enqueue(temp->right);
    }
    cout << "Количество узлов: " << count << endl;

    // Вычисление высоты
    int height = 0;
    if (tree->root) {
        SimpleQueue q2;
        q2.enqueue(tree->root);

        while (!q2.isEmpty()) {
            int levelSize = q2.getSize();
            for (int i = 0; i < levelSize; i++) {
                Node* temp = q2.dequeue();
                if (temp->left) q2.enqueue(temp->left);
                if (temp->right) q2.enqueue(temp->right);
            }
            height++;
        }
    }
    cout << "Высота дерева: " << height << endl;

    cout << "Тип дерева: ";
    if (full) { 
        cout << "СТРОГО ПОЛНОЕ БИНАРНОЕ ДЕРЕВО (Full/Strict Binary Tree)" << endl;
        cout << "- Каждый узел имеет 0 или 2 потомка" << endl;
    }
    else if (complete) {
        cout << "НЕ полное БИНАРНОЕ ДЕРЕВО (Complete Binary Tree)" << endl;
        cout << "- Все уровни полностью заполнены, кроме последнего" << endl;
        cout << "- Последний уровень заполнен слева направо" << endl;
    }
    else {
        cout << "ОБЫЧНОЕ БИНАРНОЕ ДЕРЕВО" << endl;
        cout << "- Не удовлетворяет критериям полного бинарного дерева" << endl;
    }

    // Дополнительная информация
    cout << "Максимальное количество узлов для высоты " << height << ": " << ((1 << height) - 1) << endl;
    cout << "Фактическое количество узлов: " << count << endl;

    if (complete && count == ((1 << height) - 1)) {
        cout << "Дерево является ИДЕАЛЬНЫМ бинарным деревом!" << endl;
    }
}

// Удаление узла из дерева
void deleteNode(fullBinaryTree* tree, const string& value) {
    if (!tree->root) {
        cout << "Дерево пусто!" << endl;
        return;
    }

    // Если удаляем корень и он единственный узел
    if (tree->root->data == value && !tree->root->left && !tree->root->right) {
        delete tree->root;
        tree->root = nullptr;
        cout << "Узел '" << value << "' удалён" << endl;
        return;
    }

    SimpleQueue q;
    q.enqueue(tree->root);

    Node* target = nullptr;
    Node* last = nullptr;
    Node* parentOfLast = nullptr;

    // Находим узел для удаления и последний узел
    while (!q.isEmpty()) {
        Node* temp = q.dequeue();

        if (temp->data == value) {
            target = temp;
        }

        if (temp->left) {
            parentOfLast = temp;
            last = temp->left;
            q.enqueue(temp->left);
        }
        if (temp->right) {
            parentOfLast = temp;
            last = temp->right;
            q.enqueue(temp->right);
        }
    }

    if (!target) {
        cout << "Узел '" << value << "' не найден" << endl;
        return;
    }

    // Заменяем данные целевого узла данными последнего узла
    target->data = last->data;

    // Удаляем последний узел
    if (parentOfLast->left == last) {
        parentOfLast->left = nullptr;
    }
    else {
        parentOfLast->right = nullptr;
    }

    delete last;
    cout << "Узел '" << value << "' удалён" << endl;
}


/*

./dbms --file file.data --query "CLEAR_ALL"
./dbms --file file.data --query "TINSERT_BINARY W 4"
./dbms --file file.data --query "TINSERT_BINARY W 2"
./dbms --file file.data --query "TINSERT_BINARY W 6"
./dbms --file file.data --query "TINSERT_BINARY W 1"
./dbms --file file.data --query "TINSERT_BINARY W 3"
./dbms --file file.data --query "TINSERT_BINARY W 5"
./dbms --file file.data --query "TINSERT_BINARY W 7"
./dbms --file file.data --query "TCHECK W"
./dbms --file file.data --query "PRINT T W"

*/